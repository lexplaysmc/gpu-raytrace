#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct Tri {
    vec3 v1;
    vec3 v2;
    vec3 v3;

    vec3 normal;
};

layout(binding = 0) uniform UniformBufferObject {
    uvec4 size;
    dvec4 pos;
    int inp[ ];
};
layout(std430, binding = 1) buffer OutSSBO {
    uint pixels[ ];
};

dvec2 square_complex(dvec2 x) {
    return dvec2(x.x*x.x-x.y*x.y, x.x*x.y*2);
}

dvec2 get_cam(dvec2 uv, dvec2 center, double zoom) {
    dvec2 tl = dvec2((-zoom/2)*size.x/size.y, -zoom/2)+center;
    dvec2 br = dvec2((zoom/2)*size.x/size.y, zoom/2)+center;
    return uv * (br - tl) + tl;
}
void write_pixel(uint index, vec4 col) {
    uvec4 col8 = uvec4(col * 255);
    uint color = col8.w * 256*256*256 + col8.z * 256*256 + col8.y * 256 + col8.x;
    pixels[index] = color;
}

void main() {
    if (gl_GlobalInvocationID.x >= size.x || gl_GlobalInvocationID.y >= size.y) {
        return;
    };
    // dvec2 tl = dvec2(-1.5*size.x/size.y, -1.5);
    // dvec2 br = dvec2(1.5*size.x/size.y, 1.5);
    dvec2 uv = dvec2(gl_GlobalInvocationID.xy)/dvec2(size);
    double zoom = pos.z;
    double gamma = pos.w;
    dvec2 uv_scaled = get_cam(uv, pos.xy, zoom);
    // dvec2(-1.768800555, -0.001768198), 0.000001
    uint index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y*size.x;
    // if (length(uv_scaled)<1) {
    //     pixels[index] = vec4(0.0, 0.0, 0.0, 1.0);
    // }
    dvec2 z = dvec2(0);
    uint i = 0;
    while (length(z) < 2.0 && i < 1024) {
        z = square_complex(z) + uv_scaled;
        i++;
    };
    if (i==1024) {
        write_pixel(index, vec4(0.0, 0.0, 0.0, 1.0));
    } else {
        write_pixel(index, vec4(pow(float(i)/1024, float(gamma)), 0.0, 0.0, 1.0));
    };
    // write_pixel(index, vec4(0.0, 0.0, 0.0, 1.0));
    // pixels[index] = vec4(pos);
}